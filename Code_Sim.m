clc;clear;close all;
%--- discrete event simulation -------------
N =50000;  % N is the number of transitions.

lambda = 0.1;  mu = 1;
Tran = zeros(N,1); State = zeros(N,1);
EventList = zeros(5,1);
% initialize system's state
initState = 1;      PROCESS = ['O' 'O' 'O' 'O' 'O']; 
%  status:  O - Other Resource
%           W - Waiting in queue
%           S - Served
EventList(1) = -log(rand)/lambda;
EventList(2) = -log(rand)/lambda;
EventList(3) = -log(rand)/lambda;
EventList(4) = -log(rand)/lambda;
EventList(5) = -log(rand)/lambda;
NIC_TIME = zeros(1,N);
NIC_BUSY=0;
P5=0;
P3=0;
P1=0;
P4=0;
P2=0;
NIC_Service_List = 0;
NIC_STATUS = true;
v=0;
NIC_Service_Count=0;
TotalTime=min(EventList);
% Each EventList entry should be assigned individually based on its
% Process's status.
count=0;
Q = zeros(1,5);
R= zeros(1,5);
W= zeros(1,5);
for i=1:N,     % simulate N transitions
    % find the smallest event time in the EventList
    if(count<5)
        [nextT, k] = min(EventList);
        TotalTime = EventList(k);
       
         count= count+1;
    else
        
     [value,d] = min(EventList);
     Q(d) = EventList(d);
     
   if ~isempty(Q(Q==0))
     for j =length(Q):-1:1
         
         if Q(j) ~=0
             k = j;
             P5 = P5 + 1;
             break;
         elseif (Q(j-1)) ~=0 || (Q(j-2)) ~=0
             if Q(j-1) > Q(j-2)
                 k = 4;
                  P4 = P4 + 1;
             else
                 k= 3;
                  P3 = P3 + 1;
             end
                break;
         elseif (Q(j-3)) ~= 0 || (Q(j-4)) ~=0
             if Q(j-3) > Q(j-4)
                 k = 2;
                  P3 = P3 + 1;
             else
                 k= 1;
                  P1 = P1 + 1;
             end
             break;
         end 
     end
   else
       [v4,k] = min(Q);
   end     
   
    
    
    switch(PROCESS(k))
        case 'O' ,    % the process is coming in queue
            if NIC_STATUS== true,  % there are still line available
                PROCESS(k) = 'S'; % the caller uses an available NIC
                NIC_STATUS = false;
                NIC_TIME(i) = EventList(k);
                NIC_BUSY= NIC_BUSY+5*1/mu;
                TotalTime= TotalTime + 5*1/mu;
                EventList(k) = 5*1/mu +  TotalTime;    
            else
                PROCESS(k) = 'W'; %blocked, now waiting in queue
                Q(k)= EventList(k);
                NIC_TIME(i) = EventList(k);
                TotalTime= TotalTime + 1/lambda;
                EventList(k) = 1/lambda + TotalTime;
                W(k)=W(k)+1/lambda;
            end
        case 'W' ,    % the action is a waiting in queue
            if NIC_STATUS == true,  % NIC available
                PROCESS(k) = 'S'; % the caller uses an available line
                NIC_STATUS = false;
                NIC_BUSY= NIC_BUSY+5*1/mu;
                W(k)=W(k)+1/lambda;
                % the next process uses NIC after one process finishes service
                
                TotalTime= TotalTime + 5*1/mu;
                EventList(k) = 5*1/mu + TotalTime;
            else
                PROCESS(k) = 'W'; %blocked, waiting in queue
                Q(k)=EventList(k);
                W(k)=W(k)+1/lambda;
                TotalTime = TotalTime +1/lambda;
                EventList(k) =1/lambda + TotalTime;
                
            end
         case 'S',  % the action is being served
            NIC_STATUS = true;
            PROCESS(k) = 'O';
            TotalTime= TotalTime + 1/lambda;
            EventList(k) =1/lambda + TotalTime;
%             OTHER(i) = EventList(k);
    end
    
  end   
end

